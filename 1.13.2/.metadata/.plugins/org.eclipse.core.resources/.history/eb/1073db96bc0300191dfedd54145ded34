package com.aypi.utils.xml.script;

import java.util.ArrayList;

public class ScriptManager {
	
	private ArrayList<Variable> vs;
	
	public ScriptManager() {
		this.vs = new ArrayList<Variable>();
		
		//test
	}
	
	//NUMBER
	public double product(Variable v1, Variable v2) {
		double product = 0;
		if (v1.getType() == VariableType.NUMBER && v2.getType() == VariableType.NUMBER) {
			product = Double.parseDouble(v1.getValue()) + Double.parseDouble(v2.getValue());
		} else {
			System.out.println("Error operator "+v1.getType()+" "+v2.getType()+" not compatible");
		}
		return product;
	}
	
	public double difference(Variable v1, Variable v2) {
		double difference = 0;
		if (v1.getType() == VariableType.NUMBER && v2.getType() == VariableType.NUMBER) {
			difference = Double.parseDouble(v1.getValue()) - Double.parseDouble(v2.getValue());
		} else {
			System.out.println("Error operator "+v1.getType()+" "+v2.getType()+" not compatible");
		}
		return difference;
	}
	
	public double multiplie(Variable v1, Variable v2) {
		double multiplie = 0;
		if (v1.getType() == VariableType.NUMBER && v2.getType() == VariableType.NUMBER) {
			multiplie = Double.parseDouble(v1.getValue()) * Double.parseDouble(v2.getValue());
		} else {
			System.out.println("Error operator "+v1.getType()+" "+v2.getType()+" not compatible");
		}
		return multiplie;
	}
	
	public double divide(Variable v1, Variable v2) {
		double multiplie = 0;
		if (v1.getType() == VariableType.NUMBER && v2.getType() == VariableType.NUMBER) {
			multiplie = Double.parseDouble(v1.getValue()) / Double.parseDouble(v2.getValue());
		} else {
			System.out.println("Error operator "+v1.getType()+" "+v2.getType()+" not compatible");
		}
		return multiplie;
	}
	
	//BOOLEAN
	public boolean logicOperator(Variable v1, Variable v2, LogicOperator logicOperator) {
		boolean value = false;
		
		if (v1.getType() == VariableType.BOOLEAN && v2.getType() == VariableType.BOOLEAN) {
			
			value = logicOperator(Boolean.getBoolean(v1.getValue()), Boolean.getBoolean(v2.getValue()), logicOperator);
			
		} else {
			System.out.println("Error type:"+v1.getType()+" "+v2.getType()+"not aplicable for "+v1.getName()+" "+v2.getName());
		}
		
		return value;
	}
	
	public boolean logicOperator(boolean b1, boolean b2, LogicOperator logicOperator) {
		boolean value = false;
		
		if (logicOperator == LogicOperator.AND) {
			value = b1 && b2; 
		} else if (logicOperator == LogicOperator.OR) {
			value = b1 || b2;
		} else {
			System.out.println("Error logic operator "+logicOperator+" not exist");
		}
		
		return value;
	}
	
	//STRING
	
	
	
	public ArrayList<Variable> getVariables() {
		return this.vs;
	}
	
	private String createString(char[] tab, int start, int end)  {
		String str = "";
		for (int i = start ; i < end ; i++) {
			str+=tab[i];
		}
		return str;
	}
	
	public boolean compileCodeBooleanValue(String code) {
		
		//DECOMPOSE
		
		char[] cCode = code.toCharArray();
		
		boolean searchBalise = false;
		int start = 0;
		int finish = 0;
		
		for (int i = 0 ; i < cCode.length ; i++) {
			if (cCode[i] == '(') {
				start = i+1;
				searchBalise = true;
				break;
			}
		}
		
		if (searchBalise) {
			boolean find = false;
			for (int i = (cCode.length - 1) ; i >= 0 ; i--) {
				if (cCode[i] == ')') {
					finish = i;
					find = true;
					break;
				}
			}
			
			
			
			if (find) {
				String old = createString(cCode, start, finish);
				System.out.println("----------"+old);
//				String translateValue = ""+compileCodeBooleanValue(createString(cCode, start+1, finish-1));
//				code = code.replace(old, translateValue);
			} else {
				System.out.println("Error you need to close ')' !");
			}
		}
		
		//CALCULATE
		
		code = code.replace("(", "").replace(")", "");
		
		System.out.println("[DEBUG] "+code);
		String[] args = code.split(" ");
		
		boolean finalBool = true;
		LogicOperator lo = LogicOperator.AND;
		
		for (int i = 0 ; i < args.length ; i++) {
			
			if (args[i].equalsIgnoreCase("true") || args[i].equalsIgnoreCase("false")) {
				System.out.println("[DEBUG] "+finalBool+" "+lo+" "+stringToBool(args[i])+" = "+logicOperator(finalBool, stringToBool(args[i]), lo));
				finalBool = logicOperator(finalBool, stringToBool(args[i]), lo);
				lo = LogicOperator.NULL;
			} else if (isVariable(args[i])) {
				
				System.out.println("[DEBUG] "+finalBool+" "+lo+" "+stringToBool(getVariable(args[i]).getValue())+" = "+logicOperator(finalBool, stringToBool(getVariable(args[i]).getValue()), lo));
				finalBool = logicOperator(finalBool, stringToBool(getVariable(args[i]).getValue()), lo);
				
			} else if (isLogicOperator(args[i])) {
				
				LogicOperator l = LogicOperator.valueOf(args[i]);
				if (l == LogicOperator.NOT) {
					if (i+1 < args.length && (isVariable(args[i+1]) || (args[i+1].equalsIgnoreCase("true") || args[i+1].equalsIgnoreCase("false")))) {
						if (isVariable(args[i+1])) {
							args[i+1] = ""+!stringToBool(getVariable(args[i+1]).getValue());
						} else {
							args[i+1] = ""+!stringToBool(args[i+1]);
						}
					} else {
						System.out.println("Error: the argument NOT need a coorect value...");
					}
				} else {
					lo = LogicOperator.valueOf(args[i]);
				}
				
			}
			
		}
		
		return finalBool;
		
	} 
	
	boolean stringToBool(String bool) {
		if (bool.equalsIgnoreCase("true")) {
			return true;
		}
		return false;
	}
	
	boolean isLogicOperator(String name) {
		LogicOperator lo = LogicOperator.getOperator(name);
		if (lo == LogicOperator.NULL) {
			return false;
		}
		return true;
	}
	
	public boolean isVariable(String name) {
		return getVariable(name) != null;
	}
	
	public Variable getVariable(String name) {
		
		for (Variable variable : vs) {
			if (variable.getName().equalsIgnoreCase(name)) {
				return variable;
			}
		}
		
		return null;
	}
	
	public void addVariable(Variable variable) {
		vs.add(variable);
	}
	
	public void removeVariable(Variable variable) {
		for (int i = 0 ; i < vs.size() ; i++) {
			if (vs.get(i).getName().equalsIgnoreCase(variable.getName())) {
				vs.remove(i);
				i--;
			}
		}
	}
	
}
